#!/usr/bin/env ruby
require 'fileutils'
require 'benchmark'
require 'pathname'
require 'shellwords'

ROOT = ENV.fetch('PROJECT_ROOT') { Pathname File.expand_path(['..', '..'].join(File::Separator), __FILE__) }
TMP_DIR = ENV.fetch('PROJECT_TMP_DIR') { File.join(ROOT, 'tmp/bench') }

def run_benchmark(env = '', append: '')
  cmd = build_benchmark_command(env, append: append)
  debug { cmd }
  Benchmark.measure do
    sh cmd
  end
end

def run_benchmark_at_ref(ref, env = '', append: '')
  returning_to_current_branch do
    checkout_ref(ref)
    run_benchmark(env, append: append)
  end
end

def run_benchmark_refs(start_ref, end_ref, env = '', append: '')
  refresh_temp_dir
  actual = ''
  reference = ''

  returning_to_current_branch do
    actual = run_benchmark_at_ref(start_ref, env, append: append)
    reference = run_benchmark_at_ref(end_ref, env, append: append)
  end


  report <<-REPORT


Results ============================
------------------------------------~> (Branch) #{end_ref}
  #{reference.to_s}
------------------------------------



------------------------------------~> (Actual Branch) #{start_ref}
  #{actual.to_s}
------------------------------------
  REPORT
end

# TODO: consider instead 'git bisect run'
# # https://git-scm.com/docs/git-bisect
#   git bisect run my_script arguments
#
#   Note that the script (my_script in the above example) should exit with code 0
#   if the current source code is good/old, and exit with a code between 1 and 127 (inclusive),
#   except 125, if the current source code is bad/new.
#
#   Any other exit code will abort the bisect process. It should be noted that a program that
#   terminates via exit(-1) leaves $? = 255, (see the exit(3) manual page),
#   as the value is chopped with & 0377.
#
#   The special exit code 125 should be used when the current source code cannot be tested.
#   If the script exits with this code, the current revision will be skipped.
#
# TODO with git bisect run:
#   - Handle exceptions on test run as 'skip'.
#   - Assert a diff from the previous run  or given time as 'bad'.
def run_benchmark_revisions(start_ref, end_ref, env = '', append: '')
  refresh_temp_dir

   _bundle_command = Gem.bin_path('bundler', 'bundle')
  out = Logger.new(STDERR)
  cmd_tmpl = "#{Gem.ruby} #{_bundle_command} exec %s/bench current_branch"
  cmd = build_benchmark_command(env, append: append, cmd_tmpl: cmd_tmpl)
  cmd = "bin/run-command-on-git-revisions #{start_ref} #{end_ref} '#{cmd}'"

  returning_to_current_branch do
    pid = spawn(
      { 'PROJECT_ROOT' => ROOT.to_s,
        'PROJECT_TMP_DIR' => TMP_DIR.to_s,
        'ASSERT_NOTHING' => '1'
      },
      cmd,
      out: out
    )
    Process.detach(pid)
    trap(:INT) do
      Process.kill(:INT, pid)
    end
    Process.wait(pid)
  end
end

def build_benchmark_command(env = '', append: '', shellescape: false, cmd_tmpl: 'bundle exec ruby -Ilib:test %s/*_benchmark.rb')
  tmp_dir = TMP_DIR.to_s.dup.sub(ROOT.to_s + '/', '')
  if shellescape
    tmp_dir = Shellwords.shellescape(tmp_dir)
    env = Shellwords.shellescape(env)
  end
  cmd = format(cmd_tmpl, tmp_dir)
  "#{env} #{cmd} #{append}"
end

def sh(cmd)
  refresh_temp_dir if temp_dir_empty?

  pid = fork do
    exec(cmd)
  end
  Process.wait(pid)
end

def temp_dir_empty?
  Dir[File.join(TMP_DIR, '*')].none?
end

def empty_temp_dir
  FileUtils.mkdir_p(TMP_DIR)
  Dir[File.join(TMP_DIR, '*')].each do |file|
    FileUtils.rm(file)
  end
end

def fill_temp_dir
  Dir[File.join(ROOT, 'test', 'benchmark', '*.rb')].each do |file|
    FileUtils.cp(file, File.join(TMP_DIR, File.basename(file)))
  end
  current_file = File.join(ROOT, __FILE__)
  FileUtils.cp(current_file, File.join(TMP_DIR, File.basename(current_file)))
  at_exit { empty_temp_dir }
end

def refresh_temp_dir
  empty_temp_dir
  fill_temp_dir
end

def returning_to_current_branch
  whereami = current_branch
  yield
rescue SystemExit, Interrupt
  checkout_ref(whereami)
  raise
ensure
  checkout_ref(whereami)
end

def current_branch
  @current_branch ||= `cat .git/HEAD | cut -d/ -f3,4,5`.chomp
end

def checkout_ref(ref)
  return if current_branch == ref
  report `git checkout #{ref}`.chomp
  abort "Checkout failed: #{ref}, #{$?.exitstatus}" unless $?.success?
end

# trap("INT") { checkout_ref(current_branch) } # in case of interrupt
# at_exit { $! && $!.is_a?(SystemExit) && checkout_ref(whereami) }

def report(msg = '')
  STDERR.puts msg
end

def debug
  return unless $DEBUG
  STDERR.puts "[debug] #{yield}"
end

def parse_measurement(measurement)
  if measurement.respond_to?(:utime)
    user = measurement.utime
    system = measurement.stime
    total = measurement.total
    real = measurement.real
  else
    user, system, total, real = measurement.strip.
      gsub(/[^0-9\. ]/, '').
      split(/\s+/).
      map { |time| Float(time) }
  end
  {
    :user => user,
    :system => system,
    :total => total,
    :real => real,
  }
end

def current_branch_brief
  `git log --oneline -1 #{current_branch}`.chomp
end

if $0 == __FILE__
  test_type = ARGV[0] || 'current_branch'

  case test_type
  when 'current_branch'
    run_benchmark('TIMES=1 RUN_ONCE=0', append: '&> /dev/null') # warmup
    result1 = parse_measurement(run_benchmark('RUN_ONCE=0 DISABLE_CACHE=0', append: '> /dev/null'))
    print "\t"
    result2 = parse_measurement(run_benchmark('RUN_ONCE=0 DISABLE_CACHE=1', append: '> /dev/null'))
    report "\n\t#{current_branch_brief}\n\tcaching: #{result1}\n\tno cache: #{result2}"
  when 'two_refs'
    start_ref = ARGV[1] || current_branch
    end_ref = ARGV[2] || 'master'
    run_benchmark_refs(start_ref, end_ref, 'RUN_ONCE=0', append: '> /dev/null')
  when 'across_refs'
    # TODO: Consider checking across more revisions, to automatically find problems.
    second_choice_start = 'dff607d'
    start_ref = ARGV[1] || '792fb8a9053f8db3c562dae4f40907a582dd1720'
    end_ref = ARGV[2] || 'master' # current_branch
    run_benchmark_revisions(start_ref, end_ref, 'TIMES=1000 ASSERT_NOTHING=1', append: '> /dev/null')
  else
    report "Unknown test type #{test_type}"
  end
end
