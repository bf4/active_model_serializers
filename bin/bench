#!/usr/bin/env ruby
require 'fileutils'
require 'pathname'
require 'shellwords'
require 'English'
require 'json'
require 'benchmark'
require 'benchmark/ips'

class Benchmarking
  ROOT = Pathname File.expand_path(File.join(*['..', '..']), __FILE__)
  TMP_DIR_NAME = File.join('tmp', 'bench')
  TMP_DIR = File.join(ROOT, TMP_DIR_NAME)

  attr_reader :prepend, :append, :output_path, :gem_require_paths

  def initialize(prepend: '', append: '')
    @prepend = prepend
    @append = append
    @output_path = ENV.fetch('OUTPUT_PATH') { File.join(TMP_DIR_NAME, 'data.json') }
    FileUtils.touch(output_path)
    prepend << " OUTPUT_PATH=#{output_path}"
    @gem_require_paths = []
    refresh_temp_dir
  end

  def temp_dir_empty?
    Dir[File.join(TMP_DIR, '*')].none?
  end

  def empty_temp_dir
    FileUtils.mkdir_p(TMP_DIR)
    Dir[File.join(TMP_DIR, '*')].each do |file|
      FileUtils.rm(file)
    end
  end

  def fill_temp_dir
    Dir[File.join(ROOT, 'test', 'benchmark', '*.rb')].each do |file|
      FileUtils.cp(file, File.join(TMP_DIR, File.basename(file)))
    end
    at_exit { empty_temp_dir }

    directory_name = `bundle exec gem unpack benchmark-ips --target=#{Shellwords.shellescape(TMP_DIR)}`[/benchmark-ips.+\d/]
    gem_path = File.join(TMP_DIR, directory_name)
    gem_require_paths << File.join(TMP_DIR_NAME, directory_name, 'lib')
    at_exit { FileUtils.rm_rf(gem_path) }
  end

  def refresh_temp_dir
    empty_temp_dir
    fill_temp_dir
  end

  def benchmark_tests
    tmp_dir = Shellwords.shellescape(TMP_DIR)
    sh("#{prepend} bundle exec ruby -Ilib:test:#{gem_require_paths.join(':')} #{tmp_dir}/*_benchmark.rb #{append}")
  end

  def current_branch
    @current_branch ||= `cat .git/HEAD | cut -d/ -f3,4,5`.chomp
  end

  def checkout_ref(ref)
    debug `git checkout --quiet #{ref}`.chomp
    abort "Checkout failed: #{ref}, #{$CHILD_STATUS.exitstatus}" unless $CHILD_STATUS.success?
  end

  def benchmark_revisions(ref1: nil, ref2: nil)
    ref0 = current_branch
    ref1 ||= current_branch
    ref2 ||= 'master'
    reports = {}

    revisions(ref1, ref2).each do |rev|
      debug { "Checking out: #{`git log --oneline -1 #{rev}`}" }
      checkout_ref(rev)
      benchmark_tests
      reports[rev] = JSON.load(File.read(output_path))
      clean_head
    end
    checkout_ref(ref0)
    debug "OK for all revisions!"
    reports
  rescue Exception # rubocop:disable Lint/RescueException
    STDERR.puts $!.message
    checkout_ref(ref0)
    raise
  ensure
    return reports
  end

  def revisions(start_ref, end_ref)
    cmd = "git rev-list --reverse #{start_ref}..#{end_ref}"
    `#{cmd}`.chomp.split("\n")
  end

  def benchmark_refs(ref1: nil, ref2: nil)
    ref0 = current_branch
    ref1 ||= current_branch
    ref2 ||= 'master'
    reports = {}

    run_benchmark_at_ref(ref1)
    reports[ref1] = JSON.load(File.read(output_path))

    run_benchmark_at_ref(ref2)
    reports[ref2] = JSON.load(File.read(output_path))

    checkout_ref(ref0)

    reports
  rescue Exception # rubocop:disable Lint/RescueException
    checkout_ref(ref0)
    raise
  end

  def run_benchmark
    bundle
    benchmark_tests
  end

  def run_benchmark_at_ref(ref)
    debug "Running against #{ref}"
    checkout_ref(ref)
    run_benchmark
  end

  def bundle
    sh('rm -f Gemfile.lock; bundle check || bundle --local --quiet || bundle --quiet')
  end

  def clean_head
    sh('git reset --hard --quiet')
  end

  def sh(cmd)
    debug cmd
    system(cmd)
  end

  def debug(msg = '')
    if block_given?
      STDOUT.puts yield
    else
      STDOUT.puts msg
    end
  end
end

if $PROGRAM_NAME == __FILE__
  # Example configuration using all options
  #   benchmarking = Benchmarking.new(prepend: 'TIMES=1000', append: '> /dev/null')
  # TODO: add concept of metrics_type. Probably send to initializer.
  #   metrics_type = 'ips' # 'simple'
  #   when simple, just run Benchmark.measure { run_only_caching_with_cached_serializers }
  #   for quick comparision of cache performance across branches
  benchmarking = Benchmarking.new# (append: '> /dev/null')
  test_type = ARGV[0]
  case test_type
  when 'current'
    STDERR.puts "Ran in #{benchmarking.run_benchmark} seconds."
  when 'revisions'
    reports = benchmarking.benchmark_revisions(ref1: ARGV[1], ref2: ARGV[2])
    reports.each do |name, value|
      STDERR.puts "#{name}\n\t#{value}"
    end
  else
    # Default: Compare current_branch to master
    # Optionally: pass in two refs as args to `bin/bench`
    # TODO: Consider checking across more revisions, to automatically find problems.
    reports = benchmarking.benchmark_refs(ref1: ARGV[0], ref2: ARGV[1])
    reports.each do |name, value|
      STDERR.puts "#{name}\n\t#{value}"
    end
  end
end
